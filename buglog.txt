Bug Log:


Checkpoint 1: 

1. One issue was that paging inline assembly doesn't work and just crashes. This was a semantic error and had a difficulty 
level of easy. To fix this, we opted to just make a helper .S file.

2. Another issue was that the test machine was bootlooping despite having GDT set up properly. This was a semantic error and had a difficulty level of 
medium. To fix this, we realized that we were running make dep and sudo make while the test machine was open so we only ran gdb 
after making and opening the test machine and it worked.

3. We also had an issue with rtc and keyboard test not working despite having initilalized it correctly. It turns out the PIC was 
set up incorrectly. This was an algorithmic error and had a difficulty level of medium. To fix this, we refractored the code and made sure 
all the ports were being masked and unmasked correctly. Initially, they were not but we revised our code and it worked.

4. We also had an issue with paging and failing to use the proper bit shifted location in memory and we were mapping both kernel and 
video to the wrong place. This was an algorithmic error and had a difficulty level of hard. To fix this, we bit shifted physical location 
to find the proper virtual location. 

5. We also had an issue with characters not being printed while typing. This was a semantic error and had a difficulty level of easy. 
We realized we were using a double parenthesis which was causing the handler to treat all the characters on the keyboard map as one 
char and one entry in an array. To fix this, we just simply removed the extra parenthesis. 


Checkpoint 2:

6. We had an issue with our rtc frequency tests not showing up. This was a semantic error and had a difficulty level of easy. 
To fix this, we had to use TEST_OUTPUT in our test cases instead of simply calling them. 

7. We had an issue with our cursor not following the length of our string as we were typing. This was an algorithmic error and 
had a difficulty level of medium. To fix this, we had to change our cursor functions. It turns out that we had been switching
the port and value in our outb() function. 

8. We also had an issue with showing the data of our files. It came out as mostly junk and completely incorrect. This was a 
semantic error and had a difficulty level of medium. To fix this, we had to change the signedness of our buffer pointers from
unsigned to signed. 

9. We also had an issue with our scrolling in our keyboard and terminal functionality. This was an algorithmic error and had a 
difficulty level of hard. To fix this, we had to fix the boundaries of various if statements. Essentially, the boundary 
check is what helped us move to the next line and helped complete the scrolling functionality.

10. We also had an issue with our read function for terminal not working. This was an algorithmic error and had a difficulty 
level of hard. To fix this, we simply moved the while loop outside the critical section. After this, we were able to raise 
interrupts which we were not able to do before. 


Checkpoint 3:

11. We had an issue while finding eip for the iret from execute. This is a algorithmic error and had a difficulty level of hard. we finally
use the bit shifting to the 24-27 byte for execute table and then fix the problem and find the right value of that.

12. We had a page fault issue caused by the false set up for paging structure. This is an algorithmic error and had a difficulty level of hard.
The way to fix this is re-construct the paging structure according to the manul from course website. There should be a PTE and PDE for 4kb and 
another PTE for 4MB paging. But we stuck here and didn't work through well.


Checkpoint 4:

13. We had an issue with ls not being able to run more than once which was causing our grep to not work as well. This was a semantic error and had 
a difficulty level of medium. To fix this, we just had to sequence our directory read function in our file systems properly. We had to reset the 
offset before we checked the size of the file. 

14. We had an issue with our file commands page faulting when we were typing invalid commands or empty string commands. This was also causing an error
with our syserr test 4. This was a semantic error and had a difficulty level of medium. To fix this, we had to check the lenghth of the filename and 
if it is null or equal to 0 and we also had to check if the file array is null. 

15. We had an issue with our syserr 5 which was not returning the right value of -1. As a result of this, we were failing that test and 
printing a closed unopened or invalid fd command. This was a semantic error and had a difficulty level of medium. To fix this, we had to 
sequence our current fd and fd check accordingly.

16. We had an issue with page faulting with our vidmap function. This was an algorithmic error and had a difficulty level of hard. To fix this, 
we had to make a helper function that was called in our syscall_vidmap function. This helper function reset all the page table index (33) to 0. This 
fixed our page fault errors with fish and other related commands. 


Checkpoint 5:

17. We had an issue with our kernel bootlopping after reaching the maximum number of processes. This was an algorithmic error and had a difficulty 
level of medium. To fix this, we incremented the pid in different terminals so it points to the parent of that terminal. Originally, we were
incrementing the pid no matter what. 

18. We had an issue with our kernel page faulting when switching between terminals with scheduling implemented. This was an algorithmic error and 
had a difficulty level of hard. To fix this, we needed to find the next running terminal and what we did is we did not skip the terminal without 
opening the shell. 

19. We had an issue with not clearing the keyboard buffer when switching terminals. This was an algorithmic error and had a difficulty level of 
easy. To fix this, we simply cleared the keyboard buffer accordingly.

20. We had an issue with not printing to the correct terminal. This was an algorithmic error and had a difficulty level of medium. 
Originally, we were comparing the current terminal id and the running terminal id and we were also updating the running terminal id incorrectly. 
TO fix this, we obviously updated the running terminal id correctly and accordingly and the comparison between the current terminal id and the 
running terminal id was correct from that point on. 

